@merge module Stripe {
    func getCheckoutSessions(key: String,limit : int,startId: String, verbose: Bool): Possible[Array[SrdRef[CheckoutSession]]] {
        def checkOutArray: Array[SrdRef[CheckoutSession]];
        def requestUrl:  String;
        if startId == String(""){
            requestUrl = String("https://api.stripe.com/v1/checkout/sessions");
        }else{
            requestUrl = String.format("https://api.stripe.com/v1/checkout/sessions?starting_after=%s",startId.buf);
        }
        def request : SrdRef[Net.Request];
        request = SrdRef[Net.Request]().{
            alloc()~init(requestUrl, key, String("Bearer"));
        };
        request.verbose = verbose;
        request.get();
        if request.responseHttpStatus == 401 {
            return Possible[Array[SrdRef[CheckoutSession]]].failure(Errors.unauthenticated());
        } else if request.responseHttpStatus == 0 {
            return Possible[Array[SrdRef[CheckoutSession]]].failure(Errors.connection());
        } else if request.responseHttpStatus != 200 {
            return Possible[Array[SrdRef[CheckoutSession]]].failure(Errors.unexpected());
        }
        def checkoutSessionObject: Json = request.responseBody;
        def i: int = 0;
        def objectString : String=checkoutSessionObject("object");
        if  objectString != String("list") {
            checkOutArray.add(convertToCheckoutSession(checkoutSessionObject));
        } else {
            def length : int=0;
            if  limit > checkoutSessionObject("data").getLength() or limit==-1{
                length=  checkoutSessionObject("data").getLength();
            }
            else {
                length=limit;
            }
            for i = 0, i < length, i += 1 {
                checkOutArray.add(convertToCheckoutSession(checkoutSessionObject("data")(i)));
            }
            if limit >0{
                length = limit-length;
            }
             // limit =-1 to recive all the data 
            def haseMore : bool=checkoutSessionObject("has_more");
            while haseMore and (limit ==-1 or length>0) {
                request = SrdRef[Net.Request]().{
                    alloc()~init(String.format("https://api.stripe.com/v1/checkout/sessions?starting_after=%s", checkOutArray(checkOutArray.getLength() - 1).id.buf), key, String("Bearer"));
                }
                request.verbose = verbose;
                request.get();
                if request.responseHttpStatus == 401 {
                    return Possible[Array[SrdRef[Customer]]].failure(Errors.unauthenticated());
                } else if request.responseHttpStatus == 0 {
                    return Possible[Array[SrdRef[Customer]]].failure(Errors.connection());
                } else if request.responseHttpStatus != 200 {
                    return Possible[Array[SrdRef[Customer]]].failure(Errors.unexpected());
                }
                checkoutSessionObject = request.responseBody;
                haseMore = checkoutSessionObject("has_more");
                if  length >= checkoutSessionObject("data").getLength() or limit==-1{
                    for i = 0, i < checkoutSessionObject("data").getLength(), i += 1 {
                        checkOutArray.add(convertToCheckoutSession(checkoutSessionObject("data")(i)));
                    }
                    length = length -  checkoutSessionObject("data").getLength();
                }
                else{
                    for i = 0, i < length, i += 1 {
                        checkOutArray.add(convertToCheckoutSession(checkoutSessionObject("data")(i)));
                    }
                    length=0;
                }
            }
        }
        return Possible[Array[SrdRef[CheckoutSession]]].success(checkOutArray);
    }

    func getCheckoutSession(key: String, checkoutId: String, verbose: Bool): Possible[SrdRef[CheckoutSession]] {
        def request: Net.Request(String.format("https://api.stripe.com/v1/checkout/sessions/%s", checkoutId.buf), key, String("Bearer"));
        request.verbose = verbose;
        request.get();
        if request.responseHttpStatus == 401 {
            return Possible[SrdRef[CheckoutSession]].failure(Errors.unauthenticated());
        } else if request.responseHttpStatus == 404 {
            return Possible[SrdRef[CheckoutSession]].failure(Errors.notFound());
        } else if request.responseHttpStatus == 0 {
            return Possible[SrdRef[CheckoutSession]].failure(Errors.connection());
        } else if request.responseHttpStatus != 200 {
            return Possible[SrdRef[CheckoutSession]].failure(Errors.unexpected());
        }
        def checkoutSessionObject: Json = request.responseBody;
        return Possible[SrdRef[CheckoutSession]].success(convertToCheckoutSession(checkoutSessionObject));
    }

    func createCheckoutSession(key: String, parameters: String, verbose: Bool): Possible[String] {
        def request: Net.Request(
            String("https://api.stripe.com/v1/checkout/sessions"),
            key, String("Bearer"),
            String("application/x-www-form-urlencoded")
        );
        request.verbose = verbose;
        request.post(parameters.buf);
        if request.responseHttpStatus == 401 {
            return Possible[String].failure(Errors.unauthenticated());
        } else if request.responseHttpStatus == 400 {
            return Possible[String].failure(Errors.invalidParams());
        } else if request.responseHttpStatus == 0 {
            return Possible[String].failure(Errors.connection());
        } else if request.responseHttpStatus != 200 {
            return Possible[String].failure(Errors.unexpected());
        }
        def checkOutSessionObject: Json = request.responseBody;
        return Possible[String].success(checkOutSessionObject("id"));
    }

    func createCheckoutSession(
        key: String, items: Map[String, Int], customerId: String, successUrl: CharsPtr, verbose: Bool
    ): Possible[String] {
        if items.getLength() == 0 {
            return Possible[String].failure(Errors.invalidParams());
        }
        def parameters: String;
        if customerId != String() {
            parameters = String.format(
                "mode=payment&customer=%s&success_url=%s"، customerId.buf, Net.uriEncode(successUrl).buf
            );
        } else {
            parameters = String.format("mode=payment&success_url=%s", Net.uriEncode(successUrl).buf);
        }
        def i: Int;
        for i = 0, i < items.getLength(), ++i {
            parameters += String.format(
                "&line_items[%i][price]=%s&line_items[%i][quantity]=%i"،
                i, Net.uriEncode(items.keyAt(i)).buf, i, items.valAt(i)
            );
        }
        return createCheckoutSession(key, parameters, verbose);
    }
    func convertToCheckoutSession(checkoutSessionObject: Json): SrdRef[CheckoutSession] {
        def checkoutSession: SrdRef[CheckoutSession];
        checkoutSession = SrdRef[CheckoutSession]().{
        alloc()~init(
                checkoutSessionObject("id"),
                checkoutSessionObject("client_reference_id"),
                checkoutSessionObject("cancel_url"),
                checkoutSessionObject("success_url"),
                checkoutSessionObject("url"),
                checkoutSessionObject("currency"),
                checkoutSessionObject("customer"),
                checkoutSessionObject("line_items"),
                checkoutSessionObject("mode"),
                checkoutSessionObject("payment_status"),
                checkoutSessionObject("status"),
                checkoutSessionObject("amount_total")
            )
        };
        return checkoutSession;
    }
}
